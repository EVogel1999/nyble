<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Nyble</title><link>http://example.org/posts/</link><description>Recent content in Posts on Nyble</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 15 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Intro to Solidity</title><link>http://example.org/posts/intro-solidity/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>http://example.org/posts/intro-solidity/</guid><description>Introduction Blockchain technology is a new emerging technology revolutionizing many different industries including finance (DeFi), governance (DAOs), art (NFTs), and more. There are a few languages that are popular for coding projects on the blockchain, solidity is used for EVM-based (ethereum virtual machine) blockchains.
One of the best ways to learn is by doing so this tutorial will focus on introducing the key concepts and fundamentals of solidity blockchain development with hardhat.</description><content>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>Blockchain technology is a new emerging technology revolutionizing many different industries including finance (DeFi), governance (DAOs), art (NFTs), and more. There are a few languages that are popular for coding projects on the blockchain, &lt;code>solidity&lt;/code> is used for EVM-based (ethereum virtual machine) blockchains.&lt;/p>
&lt;p>One of the best ways to learn is by doing so this tutorial will focus on introducing the key concepts and fundamentals of solidity blockchain development with &lt;code>hardhat&lt;/code>.&lt;/p>
&lt;p>All the code with comments can be found at this &lt;a href="https://github.com/EVogel1999/solidity-workshop">github repo&lt;/a>.&lt;/p>
&lt;h2 id="technology-requirements">Technology Requirements&lt;/h2>
&lt;p>To run this tutorial you need the following installed on your machine:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/download/">Node.js&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://code.visualstudio.com/Download">Visual Studio Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>To fully follow along with this tutorial it&amp;rsquo;s assumed that you know how to work with &lt;code>node.js&lt;/code> and &lt;code>javascript&lt;/code>. Also you will need to understand some key javascript concepts like &lt;code>async/await&lt;/code>.&lt;/p>
&lt;p>Here are some resources if you need to learn these concepts:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PL4cUxeGkcC9jsz4LDYc6kv3ymONOKxwBU">Net Ninja: Node.js Crash Course Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PL4cUxeGkcC9jx2TTZk3IGWKSbtugYdrlu">Net Ninja: Asynchronous Javascript Tutorial&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="project-setup">Project Setup&lt;/h1>
&lt;p>To write solidity, we will be using the &lt;a href="https://hardhat.org/">hardhat&lt;/a> development environment. This environment contains everything that is needed to develop, test, and deploy solidity smart contracts.&lt;/p>
&lt;p>To create a new hardhat project, first we need to initialize a folder using &lt;code>npm&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>npm init -y
&lt;/code>&lt;/pre>&lt;p>After that, we need to install a few dependencies and then the hardhat package will take care of the rest of the setup:&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install chai ethereum-waffle ethers @nomiclabs/hardhat-ethers @nomiclabs/hardhat-waffle @nomicfoundation/hardhat-toolbox
npx hardhat
&lt;/code>&lt;/pre>&lt;p>If you are prompted to choose a between &lt;code>javascript&lt;/code> or &lt;code>typescript&lt;/code>, choose &lt;strong>javascript&lt;/strong>.&lt;/p>
&lt;h1 id="developing-the-smart-contract">Developing the Smart Contract&lt;/h1>
&lt;p>The smart contract that we will be developing is influenced by the genre of cyberpunk. What we will be coding is a simple &lt;code>Job&lt;/code> contract that will do the following:&lt;/p>
&lt;ul>
&lt;li>Allow the job client to deposit ETH into the contract&lt;/li>
&lt;li>Allow a team of people to accept the job&lt;/li>
&lt;li>Allow the client to mark the job as finished&lt;/li>
&lt;li>Auto pay the team who accepted the job&lt;/li>
&lt;/ul>
&lt;p>Create a new &lt;code>Job.sol&lt;/code> file in the &lt;code>contracts&lt;/code> folder and copy the following code into the file:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
contract Job {
// TODO: Write code
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>To create an empty smart contract, you need the following:&lt;/p>
&lt;ul>
&lt;li>A software license identifier (for now, leave it unlicensed)&lt;/li>
&lt;li>The version of solidity you want to run&lt;/li>
&lt;li>The contract name&lt;/li>
&lt;/ul>
&lt;h2 id="registering-the-client-and-depositing-eth">Registering the Client and Depositing ETH&lt;/h2>
&lt;p>Before the client can deposit ETH into the smart contract we first need to register who the client is. To do that, we set a client variable in the constructor.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
// Enums
enum JobState {
WAITING,
ACCEPTED,
COMPLETED
}
// Job information
address private client;
JobState private state = JobState.WAITING;
constructor() {
// Sends the job client to the deployer
client = msg.sender;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>msg&lt;/code> is a global variable that can be accessed in any &lt;code>function&lt;/code> or &lt;code>modifier&lt;/code>. The &lt;code>sender&lt;/code> attribute in particular is the address (a wallet or contract address) that last called the contract. So in this particular case, the person who &lt;em>deploys&lt;/em> the smart contract is the &lt;code>msg.sender&lt;/code>.&lt;/p>
&lt;p>Now that we know who the client is for the Job, we can write the &lt;code>deposit()&lt;/code> function.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" />
&lt;label for="3">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
// Contract events
event PaymentReceived(address from, uint256 amount);
/**
* Deposits ether to the contract
*/
function deposit() payable public isClient {
// Emit an event saying the contract recieved the deposit
emit PaymentReceived(msg.sender, msg.value);
}
/**
* Check that the client isn&amp;#39;t making the transaction
*/
modifier notClient() {
require(tx.origin != client, &amp;#34;Client can&amp;#39;t perform action&amp;#34;);
_;
}
/**
* Check that the client is making the transaction
*/
modifier isClient() {
require(tx.origin == client, &amp;#34;Only client can perform action&amp;#34;);
_;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>To be able to deposit ETH into a contract the function has to be of type &lt;code>payable&lt;/code>. This is a modifier (similar to public/private visibility modifiers) that allows the function to accept token payments. We emit an &lt;code>event&lt;/code> when the client deposits ETH in order to acknowledge the deposit (we don&amp;rsquo;t need to do this but it&amp;rsquo;s good practice).&lt;/p>
&lt;p>To make sure that only the client is depositing ETH to the contract, we need to create &lt;code>modifier&lt;/code> functions. The two that are created above is &lt;code>notClient&lt;/code> and &lt;code>isClient&lt;/code>; what these two functions do is check that the person calling a particular function (such as &lt;code>deposit()&lt;/code>) is the client we defined earlier.&lt;/p>
&lt;p>Like &lt;code>msg&lt;/code>, &lt;code>tx&lt;/code> is another global variable. The difference between &lt;code>msg.sender&lt;/code> and &lt;code>tx.origin&lt;/code> is who the original wallet address that called the function. To better visualize this, the table below is provided. In the first one, contract A would register &lt;code>msg.sender&lt;/code> and &lt;code>tx.origin&lt;/code> as the same. In the second one contract B would register them as different.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Contract Call&lt;/th>
&lt;th>&lt;code>msg.sender&lt;/code>&lt;/th>
&lt;th>&lt;code>tx.origin&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Wallet -&amp;gt; A&lt;/td>
&lt;td>Wallet&lt;/td>
&lt;td>Wallet&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Wallet -&amp;gt; A -&amp;gt; B&lt;/td>
&lt;td>A&lt;/td>
&lt;td>Wallet&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
/**
* Returns the total payout for the job
*/
function getPayout() public view returns (uint256) {
return address(this).balance;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Last but not least, we also need to provide a way to easily get the total payout for the Job. This isn&amp;rsquo;t strictly necessary as you can do this with frontend javascript libraries but contains another interesting modifier we haven&amp;rsquo;t come across yet. The &lt;code>view&lt;/code> modifier is a modifier that allows the address to read the value from the blockchain &lt;strong>gas-free&lt;/strong>.&lt;/p>
&lt;p>In blockchain applications, every transaction onto the chain costs ETH (or the blockchain&amp;rsquo;s native token). So when you declare something as &lt;code>view&lt;/code> or &lt;code>pure&lt;/code> then that particular action isn&amp;rsquo;t changing the chain&amp;rsquo;s state, only reading from it and doesn&amp;rsquo;t count as a transaction.&lt;/p>
&lt;h2 id="accepting-a-job">Accepting a Job&lt;/h2>
&lt;p>Now that the client can deposit ETH for the job into the smart contract, we need to write the functionality for a group of people to accept the job. We need to include the ability to record the whole percentages of the cut for each team member.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" />
&lt;label for="5">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
// Team information
address[] private members;
uint8[] private shares;
/**
* Accepts a job with a given team array and the shares for each team member
*/
function acceptJob(address[] memory m, uint8[] memory s) external notClient {
// Check members and shares are defined and same length
require(m.length == s.length, &amp;#34;Team members and shares must be same length&amp;#34;);
require(m.length &amp;gt; 0, &amp;#34;Team must have at least one member&amp;#34;);
require (state == JobState.WAITING, &amp;#34;Job must be awaiting team&amp;#34;);
// Check the total shares is equal to 100 (100%)
uint8 total = 0;
for (uint i = 0; i &amp;lt; s.length; i&amp;#43;&amp;#43;) {
total &amp;#43;= s[i];
}
require (total == 100, &amp;#34;Shares must total to 100&amp;#34;);
// Set team members
members = m;
shares = s;
// Set contract state to accepted
state = JobState.ACCEPTED;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The first three &lt;code>require&lt;/code> statements check that the team members and shares match, that there is at least one member in the team, and that the job is waiting for someone to accept it.&lt;/p>
&lt;p>The for loop checks that the shares array total to 100 (or 100%). If it passes those checks then the members and their shares are recorded and the job&amp;rsquo;s state moves to the next state.&lt;/p>
&lt;h2 id="completing-a-job">Completing a Job&lt;/h2>
&lt;p>The only thing that&amp;rsquo;s left for this contract is for the client to complete and close out the job, automating the payments to the team members. To do the payments safely and securely, we will be using another contract called &lt;code>Open Zeppelin&lt;/code>. Open Zeppelin is a blockchain security company that offers a library of secure solidity contracts for the community to use.&lt;/p>
&lt;p>We install these contracts through &lt;code>npm&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>npm i @openzeppelin/contracts
&lt;/code>&lt;/pre>&lt;p>Then we import it using the &lt;code>import&lt;/code> statement:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import &amp;#34;@openzeppelin/contracts/utils/Address.sol&amp;#34;;
contract Job {
// ...
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="collapsable-code">
&lt;input id="7" type="checkbox" />
&lt;label for="7">
&lt;span class="collapsable-code__language">solidity&lt;/span>
&lt;span class="collapsable-code__title">Job.sol&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-solidity" >&lt;code>
/**
* Completes a job and sends out the payment to the team
*/
function complete() external isClient {
require(state == JobState.ACCEPTED, &amp;#34;Job must be accepted to complete&amp;#34;);
// Set job state
state = JobState.COMPLETED;
// Payout each team member
uint256 totalPayout = this.getPayout();
for (uint i = 0; i &amp;lt; members.length; i&amp;#43;&amp;#43;) {
uint256 cut = (totalPayout * shares[i]) / 100;
Address.sendValue(payable(members[i]), cut);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The complete function only needs to check that the job is in the accepted state, so it can later be moved to completed. Then we iterate through each team member and automate payments to them using Open Zeppelin&amp;rsquo;s &lt;code>Address&lt;/code> contract.&lt;/p>
&lt;p>What&amp;rsquo;s important to note here is that &lt;strong>solidity doesn&amp;rsquo;t have decimals&lt;/strong>, so the &lt;code>cut&lt;/code> needs to be a whole number. This is why the member&amp;rsquo;s share is multiplied by the total payout and divided by 100.&lt;/p></content></item></channel></rss>